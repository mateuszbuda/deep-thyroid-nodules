import os
import sys

import numpy as np
import tensorflow as tf
from keras import backend as K
from keras.callbacks import TensorBoard
from keras.optimizers import RMSprop
from sklearn.metrics import roc_auc_score

from data import fold_data, augment, augment_2, augment_4
from model import multitask_cnn, loss_dict, loss_weights_dict

checkpoints_dir = (
    "/home/adithya/Desktop/Adithya_Thyroid_Deep_Learning/deep-thyroid-nodules-3/checkpoints/<FOLD>/"
)
logs_dir = "/home/adithya/Desktop/Adithya_Thyroid_Deep_Learning/deep-thyroid-nodules-3/logs/<FOLD>/"

batch_size = 128
epochs = 250
base_lr = 0.001


def train(fold):
    fold_checkpoints_dir = checkpoints_dir.replace("<FOLD>", str(fold))
    fold_logs_dir = logs_dir.replace("<FOLD>", str(fold))

    if not os.path.exists(fold_checkpoints_dir):
        os.makedirs(fold_checkpoints_dir)
    if not os.path.exists(fold_logs_dir):
        os.makedirs(fold_logs_dir)

    x_train, y_train, x_test, y_test = fold_data(fold)

    print("Training and validation data processed.")
    print("Training data shape: {}".format(len(x_train)))
    print("Test data shape: {}".format(len(x_test)))

    model = multitask_cnn()

    optimizer = RMSprop(lr=base_lr)

    model.compile(
        optimizer=optimizer,
        loss=loss_dict,
        loss_weights=loss_weights_dict,
        metrics=["accuracy"],
    )

    training_log = TensorBoard(
        log_dir=os.path.join(fold_logs_dir, "log"), write_graph=False
    )

    callbacks = [training_log]

    y_train_compos = y_train["out_compos"]
    y_test_compos = y_test[1]
    
    y_train_compos = np.argmax(y_train_compos, axis=1)
    y_test_compos = np.argmax(y_test_compos, axis=1)

    print("Y_TEST SHAPE: ", y_test_compos.shape)
    
    for e in range(epochs):
        x_train_augmented = augment_4(x_train)
       
	print("X_Train.shape: ", x_train_augmented.shape, "y_train.shape: ", y_train.shape, "x_test.shape: ", x_test.shape, "y_test_compos.shape: ", y_test_compos.shape)
	 model.fit(
            x={"thyroid_input": x_train_augmented},
            y=y_train,
            validation_data=(x_test, y_test_compos),
            batch_size=batch_size,
            epochs=e + 1,
            initial_epoch=e,
            shuffle=True,
            callbacks=callbacks,
        )

        if np.mod(e + 1, 10) == 0:
            y_pred = np.argmax(model.predict(x_train, batch_size=batch_size, verbose=1), axis=1)    	
            auc_train = roc_auc_score(y_train_compos, y_pred)
            y_pred = np.argmax(model.predict(x_test, batch_size=batch_size, verbose=1), axis=1)
            
	    auc_test = roc_auc_score(y_test_compos, y_pred)
            with open(os.path.join(fold_logs_dir, "auc.txt"), "a") as auc_file:
                auc_file.write("{},{}\n".format(auc_train, auc_test))

    model.save(os.path.join(fold_checkpoints_dir, "weights.h5"))

    print("Training fold {} completed.".format(fold))


if __name__ == "__main__":

    config = tf.ConfigProto()
    config.gpu_options.allow_growth = True
    config.allow_soft_placement = True
    sess = tf.Session(config=config)
    K.set_session(sess)
    
    train_fold = 0
    device = "/gpu:1"# + sys.argv[1]
    
    while(train_fold <=9):
	print("current train fold: ", train_fold)
	with tf.device(device):
            train(train_fold)
        train_fold = train_fold + 1
       
